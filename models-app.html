<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LMArena Text Model Rankings</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        h2 {
            text-align: center;
            color: #2c3e50;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 300;
            letter-spacing: -0.5px;
            margin: 10px 0 5px 0;
        }
        .chart-container {
            width: 100%;
            max-width: 100vw;
            margin: 0 auto;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .charts-wrapper {
            display: flex;
            gap: 2%;
            justify-content: space-between;
            width: 100%;
        }

        .chart-section {
            flex: 1;
            min-width: 0;
        }

        .chart-title {
            text-align: center;
            font-size: 18px;
            font-weight: 500;
            color: #34495e;
            margin-bottom: 5px;
        }


        .legend {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .legend h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #2c3e50;
            text-align: center;
        }

        .legend-items {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid #ddd;
        }

        .y-axis text {
            font-size: 11px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-weight: 500;
            text-anchor: end;
            dominant-baseline: middle;
        }

        .label {
            font-size: 11px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 600;
        }

        .x-axis text {
            font-size: 10px;
        }

        .bar {
            rx: 3;
            ry: 3;
            filter: drop-shadow(0 1px 3px rgba(0,0,0,0.1));
        }

        .grid line {
            stroke: #e0e0e0;
            stroke-dasharray: 2,2;
            stroke-width: 0.5;
        }

        .grid path {
            stroke-width: 0;
        }

        /* Responsive design */
        @media (max-width: 1200px) {
            .charts-wrapper {
                flex-direction: column;
                gap: 30px;
            }

            .chart-section {
                max-width: 100%;
            }

            h2 {
                font-size: 24px;
            }
        }

        @media (max-width: 768px) {
            .chart-container {
                padding: 0 5px;
            }

            h2 {
                font-size: 20px;
            }

            .chart-title {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="chart-container">
        <h2>Top Text LLMs - Arena Score vs Voting Score</h2>
        <p style="text-align: center; margin: 2px 0 10px 0; font-size: 16px; color: #666; font-style: italic;">
            Discover non-proprietary models in Ollama
        </p>

        <div class="charts-wrapper">
            <div class="chart-section">
                <div class="chart-title">Arena Score</div>
                <div id="chart-arena"></div>
            </div>
            <div class="chart-section">
                <div class="chart-title">Voting Score</div>
                <div id="chart-voting"></div>
            </div>
        </div>

        <div class="legend">
            <h3>License Types</h3>
            <div class="legend-items">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #666;"></div>
                    <span>Proprietary</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #2ecc71;"></div>
                    <span>MIT</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #3498db;"></div>
                    <span>Apache 2.0</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #bdc3c7;"></div>
                    <span>Unknown</span>
                </div>
            </div>
            <div style="text-align: center; margin-top: 10px; font-size: 12px; color: #666; font-style: italic;">
                * Available in Ollama (subtle highlight)
            </div>
        </div>

       

    <script>
        const margin = { top: 20, right: 60, bottom: 30, left: 250 };

        // Calculate responsive width
        function getChartWidth() {
            const containerWidth = document.querySelector('.chart-section')?.offsetWidth || 800;
            const availableWidth = containerWidth - margin.left - margin.right - 10; // Extra padding
            return Math.max(250, availableWidth);
        }

        // Dynamic height calculation based on number of models
        function getChartHeight(dataLength) {
            const barHeight = 20; // Height per model bar
            const minHeight = 400;
            return Math.max(minHeight, dataLength * barHeight);
        }


        // Initialize charts with responsive sizing
        function initializeChartElements(dataLength) {
            const width = getChartWidth();
            const height = getChartHeight(dataLength);

            // Create Arena Score Chart
            const svgArena = d3.select("#chart-arena")
                .append("svg")
                .attr("width", "100%")
                .attr("height", height + margin.top + margin.bottom)
                .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const xArena = d3.scaleLinear().range([0, width]);
            const yArena = d3.scaleBand().range([0, height]).padding(0.1);

            const xAxisArena = svgArena.append("g")
                .attr("transform", `translate(0,${height})`)
                .attr("class", "x-axis");

            const yAxisArena = svgArena.append("g")
                .attr("class", "y-axis");

            const gridArena = svgArena.append("g")
                .attr("class", "grid");

            // Create Voting Score Chart
            const svgVoting = d3.select("#chart-voting")
                .append("svg")
                .attr("width", "100%")
                .attr("height", height + margin.top + margin.bottom)
                .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const xVoting = d3.scaleLinear().range([0, width]);
            const yVoting = d3.scaleBand().range([0, height]).padding(0.1);

            const xAxisVoting = svgVoting.append("g")
                .attr("transform", `translate(0,${height})`)
                .attr("class", "x-axis");

            const yAxisVoting = svgVoting.append("g")
                .attr("class", "y-axis");

            const gridVoting = svgVoting.append("g")
                .attr("class", "grid");

            return {
                width, height,
                svgArena, xArena, yArena, xAxisArena, yAxisArena, gridArena,
                svgVoting, xVoting, yVoting, xAxisVoting, yAxisVoting, gridVoting
            };
        }

        const animationSpeed = 750;

        // Function to truncate long model names
        function truncateText(text, maxLength = 35) {
            if (text.length <= maxLength) return text;
            return text.substring(0, maxLength - 3) + '...';
        }

        // Function to format numbers with thousand separators
        function formatNumber(num) {
            if (!num) return "";
            return Math.round(num).toLocaleString();
        }

        // Color scale for license types
        const licenseColors = {
            'Proprietary': '#666',
            'MIT': '#2ecc71',
            'Apache 2.0': '#3498db',
            '': '#bdc3c7'  // Default for empty/unknown license
        };



        function updateChart(data, scoreType, svg, x, y, xAxis, yAxis, grid, height) {
            const scoreField = scoreType === 'arena' ? 'arena_score' : 'voting_score';
            const sortedData = data.sort((a, b) => b[scoreField] - a[scoreField]);
            const paddedData = sortedData; // Show all models, no limit

            x.domain([0, d3.max(sortedData, d => d[scoreField]) + 50]);
            y.domain(paddedData.map((_, i) => i.toString()));

            xAxis.transition().duration(animationSpeed).call(d3.axisBottom(x).ticks(5));
            yAxis.transition().duration(animationSpeed).call(d3.axisLeft(y).tickFormat(i => truncateText(paddedData[i].model)));

            // Add subtle grid lines
            grid.transition().duration(animationSpeed)
                .call(d3.axisBottom(x)
                    .ticks(5)
                    .tickSize(-height)
                    .tickFormat("")
                );

            // Add subtle background rectangles for Ollama models
            yAxis.selectAll(".ollama-bg").remove(); // Remove existing backgrounds
            yAxis.selectAll(".ollama-bg")
                .data(paddedData.map((d, i) => ({...d, index: i})).filter(d => d.isInOllama))
                .enter()
                .append("rect")
                .attr("class", "ollama-bg")
                .attr("x", -245)
                .attr("y", (d) => y(d.index.toString()) + 1)
                .attr("width", 240)
                .attr("height", y.bandwidth() - 2)
                .attr("fill", "#fff9c4")
                .attr("stroke", "#f9d71c")
                .attr("stroke-width", 0.5)
                .attr("rx", 2)
                .attr("ry", 2)
                .attr("opacity", 0.8);

            // Color the y-axis text based on license and Ollama availability
            yAxis.selectAll(".tick text")
                .attr("fill", (d, i) => {
                    if (!paddedData[i]) return "#000";

                    // Black text for Ollama models (on yellow background)
                    if (paddedData[i].isInOllama) {
                        return "#000";
                    }

                    // Grey only for proprietary models
                    if (paddedData[i].license === "Proprietary") {
                        return "#999";
                    }

                    // Black for open source and unknown models
                    return "#000";
                });

            const bars = svg.selectAll(".bar")
                .data(paddedData, (d, i) => d.model || i);

            bars.enter()
                .append("rect")
                .attr("class", "bar")
                .attr("x", 0)
                .attr("y", (d, i) => y(i.toString()))
                .attr("height", y.bandwidth())
                .attr("rx", 3)
                .attr("ry", 3)
                .attr("fill", d => d.model ? (licenseColors[d.license] || licenseColors['']) : "transparent")
                .attr("width", 0)
                .merge(bars)
                .transition()
                .duration(animationSpeed)
                .attr("x", 0)
                .attr("y", (d, i) => y(i.toString()))
                .attr("width", d => x(d[scoreField]))
                .attr("height", y.bandwidth())
                .attr("fill", d => d.model ? (licenseColors[d.license] || licenseColors['']) : "transparent");

            bars.exit().remove();

            const labels = svg.selectAll(".label")
                .data(paddedData, (d, i) => d.model || i);

            labels.enter()
                .append("text")
                .attr("class", "label")
                .attr("x", d => Math.min(x(d[scoreField]) + 5, x.range()[1] - 40))
                .attr("y", (d, i) => y(i.toString()) + y.bandwidth() / 2)
                .attr("dy", "0.35em")
                .merge(labels)
                .transition()
                .duration(animationSpeed)
                .attr("x", d => Math.min(x(d[scoreField]) + 5, x.range()[1] - 40))
                .attr("y", (d, i) => y(i.toString()) + y.bandwidth() / 2)
                .attr("fill", d => d.license === "Proprietary" ? "#999" : "#000")
                .text(d => formatNumber(d[scoreField]));

            labels.exit().remove();
        }

        // Function to load ollama models for comparison
        async function loadOllamaModels() {
            try {
                const response = await fetch('ollama-models.csv');
                const csvText = await response.text();
                const lines = csvText.trim().split('\n');
                const ollamaModels = new Set();

                // Skip header and extract model names
                lines.slice(1).forEach(line => {
                    const modelName = line.split(',')[0];
                    if (modelName) {
                        ollamaModels.add(modelName.trim());
                    }
                });

                return ollamaModels;
            } catch (error) {
                console.error('Error loading Ollama models:', error);
                return new Set();
            }
        }

        // Function to load and process CSV data
        async function loadCSVData() {
            try {
                const [lmarenaResponse, ollamaModels] = await Promise.all([
                    fetch('lmarena_text.csv'),
                    loadOllamaModels()
                ]);
                const csvText = await lmarenaResponse.text();

                // Parse CSV with proper handling of quoted fields
                const lines = csvText.trim().split('\n');
                const headers = lines[0].split(',');

                const data = lines.slice(1).map(line => {
                    // Simple CSV parser that handles basic cases
                    const values = [];
                    let current = '';
                    let inQuotes = false;

                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            values.push(current.trim());
                            current = '';
                        } else {
                            current += char;
                        }
                    }
                    values.push(current.trim()); // Add the last value

                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = values[index] || '';
                    });

                    // Convert arena_score to number and votes
                    const arenaScore = parseInt(row.arena_score);
                    const votes = parseInt(row.votes);

                    // Check if model is available in Ollama
                    const isInOllama = ollamaModels.has(row.model);
                    const displayName = isInOllama ? `${row.model} *` : row.model;

                    return {
                        date: "2025-01-01",
                        model: displayName,
                        arena_score: arenaScore,
                        voting_score: votes,
                        license: row.license || "",
                        isInOllama: isInOllama
                    };
                });

                // Return all models and return
                return data;

            } catch (error) {
                console.error('Error loading CSV:', error);
                // No fallback
                return [];
            }
        }

        // Initialize both charts with CSV data
        async function initializeCharts() {
            const data = await loadCSVData();
            const chartElements = initializeChartElements(data.length);

            updateChart(data, 'arena', chartElements.svgArena, chartElements.xArena, chartElements.yArena,
                       chartElements.xAxisArena, chartElements.yAxisArena, chartElements.gridArena, chartElements.height);
            updateChart(data, 'voting', chartElements.svgVoting, chartElements.xVoting, chartElements.yVoting,
                       chartElements.xAxisVoting, chartElements.yAxisVoting, chartElements.gridVoting, chartElements.height);
        }

        // Start the application when DOM is ready
        document.addEventListener('DOMContentLoaded', initializeCharts);

    </script>
            <div style="text-align: center; margin-bottom: 10px; font-size: 14px; color: #666;">
            Data from <a href="https://lmarena.ai/leaderboard" target="_blank" style="color: #3498db;">LMArena Leaderboard</a> |
            CSV source 2025.09.02 Latest: <a href="https://github.com/fboulnois/llm-leaderboard-csv/releases" target="_blank" style="color: #3498db;">llm-leaderboard-csv</a>
        </div>
</body>
</html>
